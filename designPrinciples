Ref-ch01
###-###
Identify the aspects of the application that vary and separate them.
Take parts that vary and encapsulate them so that later you can extend or 
-alter them without affecting those that don't

###-###
Program to an interface and not to an implementation.
The above principle gives the client 
-flexibility at runtime to change the behavior of the class being referenced (polymorphism). 
Also decouples client from the actual implementation as the client is not aware of the 
-always deals with the interface. Provides loose coupling and gives more flexibility.

Coding to a concrete class, say we add a new functionality, the code in the concrete class
-will have to change to accommodate the new change.
Coding to an interface, any new functionality could be implemented in a class that implements 
-the same interface, that way new functionality can be referred thru polymorphism without any
-change to the existing code.

###-###
Favor Composition (HAS A) over Inheritance(extends).
Composition gives the scope for runtime modification of the composed reference provided
-it follows proper interface implementation.

When class inherit behavior by sub classing, this behavior is set statically  at compile time.
-In addition all sub class must inherit the same behavior.
When class extends behavior by composition, this behavior can be set dynamically at runtime.

Ref-ch02
###-###
Strive for loosely coupled designs between the objects that interact.
Loose coupling ==> less dependency ==> more flexibility

Ref-ch03
###-###
Classes should be open for extension and closed for modification.

Ref-ch04
###-###
Depend upon Abstraction and not on Concrete Classes.

Ref-ch07_1
###-###
Principle of least Knowledge - talk only to your immediate friends.
This principle prevents us from creating designs that have a large number of classes
-coupled together.

Ref-ch08
###-###
Hollywood Principle - Don't call us, we will call you.
Low-level components do not call High-level components directly.
